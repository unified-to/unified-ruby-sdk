# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: true
# frozen_string_literal: true


module UnifiedRubySDK
  module Models
    module Shared
    

      class CalendarEventRecurrence
        extend T::Sig
        include Crystalline::MetadataFields


        field :count, Crystalline::Nilable.new(::Float), { 'format_json': { 'letter_case': ::UnifiedRubySDK::Utils.field_name('count') } }

        field :end_at, Crystalline::Nilable.new(::DateTime), { 'format_json': { 'letter_case': ::UnifiedRubySDK::Utils.field_name('end_at'), 'decoder': Utils.datetime_from_iso_format(true) } }
        # dates to exclude from the recurrence, defaults to undefined (no exclusions)
        field :excluded_dates, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'format_json': { 'letter_case': ::UnifiedRubySDK::Utils.field_name('excluded_dates') } }

        field :frequency, Crystalline::Nilable.new(Models::Shared::CalendarEventRecurrenceFrequency), { 'format_json': { 'letter_case': ::UnifiedRubySDK::Utils.field_name('frequency'), 'decoder': Utils.enum_from_string(Models::Shared::CalendarEventRecurrenceFrequency, true) } }
        # dates to include in the recurrence, defaults to undefined (no inclusions)
        field :included_dates, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'format_json': { 'letter_case': ::UnifiedRubySDK::Utils.field_name('included_dates') } }

        field :interval, Crystalline::Nilable.new(::Float), { 'format_json': { 'letter_case': ::UnifiedRubySDK::Utils.field_name('interval') } }
        # days of the week to repeat on, defaults to undefined (every day), only used if frequency is WEEKLY
        field :on_days, Crystalline::Nilable.new(Crystalline::Array.new(Models::Shared::PropertyCalendarEventRecurrenceOnDays)), { 'format_json': { 'letter_case': ::UnifiedRubySDK::Utils.field_name('on_days') } }
        # days of the month to repeat on, defaults to undefined (every day), only used if frequency is MONTHLY
        field :on_month_days, Crystalline::Nilable.new(Crystalline::Array.new(::Float)), { 'format_json': { 'letter_case': ::UnifiedRubySDK::Utils.field_name('on_month_days') } }
        # months of the year to repeat on, defaults to undefined (every month), only used if frequency is YEARLY, January is 1
        field :on_months, Crystalline::Nilable.new(Crystalline::Array.new(::Float)), { 'format_json': { 'letter_case': ::UnifiedRubySDK::Utils.field_name('on_months') } }
        # week ordinals for BYDAY (e.g., -1 for last, -2 for second-to-last, 1 for first, 2 for second), only used with on_days. 0 is used for days without week ordinals.
        field :on_weeks, Crystalline::Nilable.new(Crystalline::Array.new(::Float)), { 'format_json': { 'letter_case': ::UnifiedRubySDK::Utils.field_name('on_weeks') } }
        # days of the year to repeat on, defaults to undefined (every day), only used if frequency is YEARLY
        field :on_year_days, Crystalline::Nilable.new(Crystalline::Array.new(::Float)), { 'format_json': { 'letter_case': ::UnifiedRubySDK::Utils.field_name('on_year_days') } }
        # timezone, defaults to undefined (no timezone)
        field :timezone, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'format_json': { 'letter_case': ::UnifiedRubySDK::Utils.field_name('timezone') } }

        field :week_start, Crystalline::Nilable.new(Models::Shared::WeekStart), { 'format_json': { 'letter_case': ::UnifiedRubySDK::Utils.field_name('week_start'), 'decoder': Utils.enum_from_string(Models::Shared::WeekStart, true) } }

        sig { params(count: T.nilable(::Float), end_at: T.nilable(::DateTime), excluded_dates: T.nilable(T::Array[::String]), frequency: T.nilable(Models::Shared::CalendarEventRecurrenceFrequency), included_dates: T.nilable(T::Array[::String]), interval: T.nilable(::Float), on_days: T.nilable(T::Array[Models::Shared::PropertyCalendarEventRecurrenceOnDays]), on_month_days: T.nilable(T::Array[::Float]), on_months: T.nilable(T::Array[::Float]), on_weeks: T.nilable(T::Array[::Float]), on_year_days: T.nilable(T::Array[::Float]), timezone: T.nilable(T::Array[::String]), week_start: T.nilable(Models::Shared::WeekStart)).void }
        def initialize(count: nil, end_at: nil, excluded_dates: nil, frequency: nil, included_dates: nil, interval: nil, on_days: nil, on_month_days: nil, on_months: nil, on_weeks: nil, on_year_days: nil, timezone: nil, week_start: nil)
          @count = count
          @end_at = end_at
          @excluded_dates = excluded_dates
          @frequency = frequency
          @included_dates = included_dates
          @interval = interval
          @on_days = on_days
          @on_month_days = on_month_days
          @on_months = on_months
          @on_weeks = on_weeks
          @on_year_days = on_year_days
          @timezone = timezone
          @week_start = week_start
        end

        sig { params(other: T.untyped).returns(T::Boolean) }
        def ==(other)
          return false unless other.is_a? self.class
          return false unless @count == other.count
          return false unless @end_at == other.end_at
          return false unless @excluded_dates == other.excluded_dates
          return false unless @frequency == other.frequency
          return false unless @included_dates == other.included_dates
          return false unless @interval == other.interval
          return false unless @on_days == other.on_days
          return false unless @on_month_days == other.on_month_days
          return false unless @on_months == other.on_months
          return false unless @on_weeks == other.on_weeks
          return false unless @on_year_days == other.on_year_days
          return false unless @timezone == other.timezone
          return false unless @week_start == other.week_start
          true
        end
      end
    end
  end
end
