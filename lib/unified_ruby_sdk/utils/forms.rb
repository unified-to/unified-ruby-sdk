# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: true
# frozen_string_literal: true

require 'cgi'
require 'date'
require 'base64'
require 'sorbet-runtime'

module UnifiedRubySDK
  module Utils
    extend T::Sig

    sig do
      params(field_name: String, explode: T::Boolean, obj: Object, delimiter: String,
             get_field_name_lambda: T.proc.params(obj_field: ::Crystalline::MetadataFields::Field).returns(String))
        .returns(T::Hash[String, T::Array[String]])
    end
    def self._populate_form(field_name, explode, obj, delimiter, &get_field_name_lambda)
      params = {}

      return params if obj.nil?

      if obj.respond_to? :fields
        items = []
        T.unsafe(obj).fields.each do |obj_field|
          obj_field_name = get_field_name_lambda.call(obj_field)
          next if obj_field_name == ''

          val = obj.send(obj_field.name.to_sym)
          next if val.nil?

          if explode
            params[obj_field_name] = [val_to_string(val)]
          else
            items.append("#{obj_field_name}#{delimiter}#{val_to_string(val)}")
          end
        end

        params[field_name] = [items.join(delimiter)] if !items.empty?
      elsif obj.is_a? Hash
        items = []
        obj.each do |key, value|
          next if value.nil?

          if explode
            params[key] = val_to_string(value)
          else
            items.append("#{key}#{delimiter}#{val_to_string(value)}")
          end
        end
        params[field_name] = [items.join(delimiter)] if !items.empty?

      elsif obj.is_a? Array
        items = []
        obj.each do |value|
          next if value.nil?

          if explode
            params[field_name] = [] if !params.key? field_name

            params[field_name].append(val_to_string(value))
          else
            items.append(val_to_string(value))
          end
        end
        params[field_name] = items.map(&:to_s).join(delimiter) if !items.empty?

      else
        params[field_name] = val_to_string(obj)
      end
      params
    end

    sig { params(media_type: String, request: Object).returns([String, Object, T::Array[T::Array[T.any(T::Array[T.nilable(String)], String)]]]) }
    def self.serialize_multipart_form(media_type, request)
      form = []
      T.unsafe(request).fields.each do |field|
        val = request.send(field.name)
        next if val.nil?

        field_metadata = field.metadata[:multipart_form]
        next if field_metadata.nil?

        if field_metadata[:file] == true
          field_name = field_metadata[:field_name]
          
          # Handle arrays of files
          if val.is_a? Array
            val.each do |file_obj|
              file_name = T.let('', String)
              content = nil

              T.must(file_obj).fields.each do |file_field|
                file_metadata = file_field.metadata[:multipart_form]
                next if file_metadata.nil?

                if file_metadata[:content] == true
                  content = T.let(file_obj.send(file_field.name), String)
                else
                  file_name = T.let(file_obj.send(file_field.name), String)
                end
              end
              raise StandardError, 'invalid multipart/form-data file' if T.unsafe(file_name) == '' || T.unsafe(content).nil?

              form.append([field_name, [file_name, content]])
            end
          else
            # Handle single file
            file_name = T.let('', String)
            content = nil

            T.must(val).fields.each do |file_field|
              file_metadata = file_field.metadata[:multipart_form]
              next if file_metadata.nil?

              if file_metadata[:content] == true
                content = T.let(val.send(file_field.name), String)
              else
                file_name = T.let(val.send(file_field.name), String)
              end
            end
            raise StandardError, 'invalid multipart/form-data file' if T.unsafe(file_name) == '' || T.unsafe(content).nil?

            form.append([field_name, [file_name, content]])
          end
        elsif field_metadata[:json] == true
          to_append = [
            field_metadata.fetch(:field_name, field.name), [
              nil, ::Crystalline.to_json(val), 'application/json'
            ]
          ]
          form.append(to_append)
        else
          field_name = field_metadata.fetch(
            :field_name, field.name
          )
          if val.is_a? Array
            val.each do |value|
              next if value.nil?

              form.append(
                ["#{field_name}[]", [nil, val_to_string(value)]]
              )
            end
          else
            form.append([field_name, [nil, val_to_string(val)]])
          end
        end
      end
      [media_type, nil, form]
    end


    sig do
      params(data: T.any(Object, T::Hash[String, String]))
        .returns(T::Hash[T.any(String, Symbol), Object])
    end
    def self.serialize_form_data(data)
      get_form_field_name = lambda do |obj_field|
        obj_param_metadata = obj_field.metadata[:form]

        return T.let({}, T::Hash[T.any(String, Symbol), Object]) if obj_param_metadata.nil?

        return obj_param_metadata.fetch(:field_name, obj_field.name)
      end

      form = T.let({}, T::Hash[T.any(String, Symbol), Object])
      if data.respond_to? :fields
        T.unsafe(data).fields.each do |field|
          val = data.send(field.name)
          next if val.nil?

          metadata = field.metadata[:form]

          next if metadata.nil?

          field_name = metadata.fetch(:field_name, field.name)

          if metadata[:json]
            form[field_name] = ::Crystalline.to_json(val)
          else
            if metadata.fetch(:style, 'form') == 'form'
              form = form.merge(
                _populate_form(
                  field_name, metadata.fetch(:explode, true), val, ',', &get_form_field_name
                )
              )
            else
              raise StandardError, "Invalid form style for field #{field.name}"
            end
          end
        end
      elsif data.is_a? Hash
        data.each do |key, value|
          form[key] = [val_to_string(value)]
        end
      else
        raise StandardError, "Invalid request body type #{data.class}"
      end

      form
    end
  end
end
