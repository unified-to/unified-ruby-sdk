# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: true
# frozen_string_literal: true

require 'cgi'
require 'date'
require 'base64'
require 'stringio'
require 'sorbet-runtime'

module UnifiedRubySDK
  module Utils
    include Kernel
    extend T::Sig

    sig { params(val: Object).returns(String) }
    def self.val_to_string(val)
      if val.class.respond_to?(:enums)
        T.unsafe(val).serialize.to_s
      elsif val.is_a? DateTime
        val.strftime('%Y-%m-%dT%H:%M:%S.%NZ')
      else
        val.to_s

      end
    end

    sig do
      params(metadata: T::Hash[Symbol, String], field_name: String, obj: Object)
        .returns(T::Hash[Symbol, T::Array[String]])
    end
    def self._get_serialized_params(metadata, field_name, obj)
      params = {}

      serialization = metadata.fetch(:serialization, '')
      params[metadata.fetch(:field_name, field_name)] = [obj.to_json] if serialization == 'json'

      params
    end


    sig { params(status: Integer).returns(T::Boolean) }
    def self.error_status?(status)
      status_major = status / 100
      return true if status_major == 4
      return true if status_major == 5

      false
    end

    sig { params(content_type: String, pattern: String).returns(T::Boolean) }
    def self.match_content_type(content_type, pattern)
      return true if content_type == pattern || ['*', '*/*'].include?(pattern)

      pieces = content_type.split(';')
      pieces.each do |piece|
        return true if pattern == piece.strip
      end

      false
    end

    sig { params(status_code: Integer, status_codes: T::Array[String]).returns(T::Boolean) }
    def self.match_status_code(status_code, status_codes)
      return true if status_codes.include? 'default'
      status_code = status_code.to_s
      status_codes.each do |code|
        return true if code == status_code
        return true if code.downcase.end_with?('xx') && status_code[0] == code[0]
      end
      false
    end

    sig { params(optional: T::Boolean).returns(T.proc.params(s: String).returns(T.nilable(DateTime))) }
    def self.datetime_from_iso_format(optional)
      Kernel.lambda do |s|
        return nil if optional && s.nil?

        return DateTime.strptime(s, '%Y-%m-%dT%H:%M:%S.%NZ')
      end
    end

    sig { params(optional: T::Boolean).returns(T.proc.params(s: String).returns(T.nilable(Date))) }
    def self.date_from_iso_format(optional)
      Kernel.lambda do |s|
        return nil if optional && s.nil?

        return Date.iso8601(s)
      end
    end

    sig do
      params(enum_type: T.class_of(T::Enum), optional: T::Boolean)
        .returns(T.nilable(T.proc.params(s: String).returns(T.nilable(T::Enum))))
    end
    def self.enum_from_string(enum_type, optional)
      Kernel.lambda do |s|
        return nil if optional && s.nil?

        return enum_type.deserialize(s)
      end
    end

    sig { params(name: String).returns(T.proc.returns(String)) }
    def self.field_name(name)
      T.let(proc { name }, T.proc.returns(String))
    end


    sig { params(field: ::Crystalline::MetadataFields::Field, data_class: Object).returns(Object) }
    def self.parse_field(field, data_class)
      field_metadata = field.metadata[:metadata_string]
      return nil if field_metadata.nil?

      field_value = data_class.send(field.name)
      return nil if field_value.nil?

      field_value
    end

    sig do
      params(form: T::Array[T::Array[T.any(String, T::Array[T.nilable(String)])]])
        .returns(T::Hash[Symbol, Object])
    end
    def self.encode_form(form)
      payload = {}
      form.each do |field_name, field|
        field = T.must(field)
        if field.length == 2
          if field[0].nil?
            # Handle multiple values for the same field name (arrays)
            if payload.key?(field_name)
              # Convert to array if not already
              unless payload[field_name].is_a?(Array)
                payload[field_name] = [payload[field_name]]
              end
              payload[field_name] << field[1]
            else
              payload[field_name] = field[1]
            end
          else
            # Handle file uploads
            file_part = Faraday::Multipart::FilePart.new(
              StringIO.new(T.must(field[1])),
              'application/octet-stream',
              field[0]
            )
            
            # Handle multiple files for the same field name (arrays)
            if payload.key?(field_name)
              unless payload[field_name].is_a?(Array)
                payload[field_name] = [payload[field_name]]
              end
              payload[field_name] << file_part
            else
              payload[field_name] = file_part
            end
          end
        elsif field.length == 3
          param_part = Faraday::Multipart::ParamPart.new(field[1].to_json, field[2])
          
          # Handle multiple values for the same field name (arrays)
          if payload.key?(field_name)
            unless payload[field_name].is_a?(Array)
              payload[field_name] = [payload[field_name]]
            end
            payload[field_name] << param_part
          else
            payload[field_name] = param_part
          end
        end
      end
      payload
    end

    sig { params(param_name: Symbol, value: Object, param_type: String, gbls: T.nilable(T::Hash[Symbol, T::Hash[Symbol, T::Hash[Symbol, Object]]])).returns(Object) }
    def self._populate_from_globals(param_name, value, param_type, gbls)
      if value.nil? && !gbls.nil?
        global_value = gbls.dig(:parameters, param_type.to_sym, param_name.to_sym)
        value = global_value if !global_value.nil?
      end
      value
    end

  end
end
