# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: true
# frozen_string_literal: true

require_relative './types'

require 'sorbet-runtime'

module UnifiedRubySDK
  module SDKHooks
    class Hooks
      extend T::Sig

      sig { void }
      def initialize
        @sdk_init_hooks = T.let([], T::Array[AbstractSDKInitHook])
        @before_request_hooks = T.let([], T::Array[AbstractBeforeRequestHook])
        @after_success_hooks = T.let([], T::Array[AbstractAfterSuccessHook])
        @after_error_hooks = T.let([], T::Array[AbstractAfterErrorHook])
      end

      sig { params(hook: AbstractSDKInitHook).void }
      def register_sdk_init_hook(hook)
        @sdk_init_hooks << hook
      end

      sig { params(hook: AbstractBeforeRequestHook).void }
      def register_before_request_hook(hook)
        @before_request_hooks << hook
      end

      sig { params(hook: AbstractAfterSuccessHook).void }
      def register_after_success_hook(hook)
        @after_success_hooks << hook
      end

      sig { params(hook: AbstractAfterErrorHook).void }
      def register_after_error_hook(hook)
        @after_error_hooks << hook
      end

      sig do
        params(
          base_url: String,
          client: Faraday::Connection
        ).returns([String, Faraday::Connection])
      end
      def sdk_init(base_url:, client:)
        @sdk_init_hooks.each do |hook|
          base_url, client = hook.sdk_init(base_url: base_url, client: client)
        end

        return base_url, client
      end

      sig do
        params(
          hook_ctx: BeforeRequestHookContext,
          request: Faraday::Request
        ).returns(Faraday::Request)
      end
      def before_request(hook_ctx:, request:)
        @before_request_hooks.each do |hook|
          request = hook.before_request(hook_ctx: hook_ctx, request: request)
        end

        request
      end

      sig do
        params(
          hook_ctx: AfterSuccessHookContext,
          response: Faraday::Response
        ).returns(Faraday::Response)
      end
      def after_success(hook_ctx:, response:)
        @after_success_hooks.each do |hook|
          response = hook.after_success(hook_ctx: hook_ctx, response: response)
        end

        response
      end

      sig do
        params(
          error: T.nilable(StandardError),
          hook_ctx: AfterErrorHookContext,
          response: T.nilable(Faraday::Response)
        ).returns(T.nilable(Faraday::Response))
      end
      def after_error(error:, hook_ctx:, response:)
        @after_error_hooks.each do |hook|
          response = hook.after_error(error: error, hook_ctx: hook_ctx, response: response)
        end

        response
      end
    end
  end
end
